{"meta":{"title":"Jarvis' blog","subtitle":"","description":"落叶飘零，又是一个春夏秋冬","author":"Jarvis","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-05-26T10:19:48.000Z","updated":"2021-05-26T12:50:24.945Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-05-26T10:22:00.000Z","updated":"2021-05-29T16:47:06.207Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个热爱生活的人努力学习，天天向上！"},{"title":"categories","date":"2021-05-26T10:19:48.000Z","updated":"2021-05-26T15:12:10.872Z","comments":false,"path":"categories/技术/index.html","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-26T10:21:30.000Z","updated":"2021-05-26T10:21:30.131Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"conmment","date":"2021-05-26T10:22:22.000Z","updated":"2021-05-26T14:41:06.025Z","comments":true,"path":"conmment/index.html","permalink":"http://example.com/conmment/index.html","excerpt":"","text":""}],"posts":[{"title":"记录一下数学建模国赛获得省赛二等奖","slug":"2021数模国赛","date":"2021-10-28T12:41:32.755Z","updated":"2021-10-28T13:31:37.698Z","comments":true,"path":"2021/10/28/2021数模国赛/","link":"","permalink":"http://example.com/2021/10/28/2021%E6%95%B0%E6%A8%A1%E5%9B%BD%E8%B5%9B/","excerpt":"","text":"2021.9.9-2021.9.12 数模国赛C题 随机分布下原料订购运输最优方案规划论文摘要目前供应商的选择在制造型企业中越来越受到重视。基于此，本文旨在建立随机规划模型与双目标优化模型来制定合适的原料订购与转运方案，分析了方案的具体实施效果，并考虑了提高产能目标下的最优方案设计。 首先，对原始数据预处理，再按照订货频率进行K −means 聚类，分出长期合作的第Ⅰ 类供应商、适中的第Ⅱ 类供应商和解决突发情况的第Ⅲ 类供应商。 针对问题一，在进行Pearson 相关系数检验后，量化出订货总量、订货频率、供货缺失百分比这三个指标。其次，对分出的3 类供应商按照指标分别进行TOPSIS 综合评价，确定出各类供应商的得分排名情况。考虑到第Ⅰ 类供应商为最重要的长期合作对象，所以在Ⅰ、Ⅱ、Ⅲ 类中分别选出排名靠前的30、10、10 家供应商，最终确定对企业而言最为重要的50 家供应商。 针对问题二，首先引入随机性概念，通过Matlab 的ksdensity 函数拟合得到每周的概率密度分布。接着在满足置信度大于0.9 的条件下求得各个供货商在未来24 周供货量。在第一小问中，考虑以最少的供货商为目标建立随机规划模型，通过遍历求得至少需要33 家供货商才可能满足周产能需求。在第二小问中，假设原材料运输和储存的单位费用为C 类订购费用的10%，再以最少的订购和储存费用为目标建立规划模型，利用贪心算法得出最经济的订购方案，需要花费489359 元，相比于历史费用下降了4.79%。在第三小问中，以最小的损耗量为目标建立规划模型，通过贪心算法求得最优转运方案，此时损耗量为710.39m3，相比于历史损耗量下降了1.42%。 针对问题三，以转运与仓储成本和损耗率最小这两个目标建立双目标优化模型，并且需要满足仓储和转运量的约束条件。接着加入成本最小这一目标，假设原材料运输和存储费用与问题二相同，基于遗传算法求得该方案下的总费用为508200 元，相较于历史费用下降了2.35%，A 增加了8690m3，损耗率仅为0.18%，下降了4.52%。 针对问题四，考虑到订货需求与供货时间上的不对等，导致难以充分利用供应商生产能力。因此需要重新确定供货量，对处理应急情况的第Ⅲ 类供应商供货量赋予衰减系数，并由排名确定衰减系数大小。之后，建立以最大产能为目标的规划模型，并给出转运量和供货的约束条件。利用贪心算法求得每周产能能够提高至31127m3，较原周产能提高了11.43%。 同时，本文就企业产能对供应商的选取数量的影响进行了灵敏度分析，发现产能在[2.6×104, 2.78×104]m3 范围时对供应商数量影响较大，同时当产能目标定在2.82 × 104m3 附近范围时供货商数量始终保持在33 不变，说明算法鲁棒性较强。 关键词: TOPSIS 随机规划双目标 优化贪心算法 衰减系数 论文下载Download","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"用matlab实现遗传算法","slug":"遗传算法","date":"2021-06-07T04:00:56.656Z","updated":"2021-06-07T04:48:44.767Z","comments":true,"path":"2021/06/07/遗传算法/","link":"","permalink":"http://example.com/2021/06/07/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/","excerpt":"","text":"比较具体地说明：https://www.jianshu.com/p/ae5157c26af9 Quick Start遗传算法的定义遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。 其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。 遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。 遗传算法执行过程遗传算法是从代表问题可能潜在的解集的一个种群（population）开始的，而一个种群则由经过基因（gene）编码的一定数目的个体(individual)组成。每个个体实际上是染色体(chromosome)带有特征的实体。 染色体作为遗传物质的主要载体，即多个基因的集合，其内部表现（即基因型）是某种基因组合，它决定了个体的形状的外部表现，如黑头发的特征是由染色体中控制这一特征的某种基因组合决定的。因此，在一开始需要实现从表现型到基因型的映射即编码工作。由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码。 初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。 这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。 遗传算法的图解 相关术语基因型(genotype)：性状染色体的内部表现； 表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现； 进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。 适应度(fitness)：度量某个物种对于生存环境的适应程度。 选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。 复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。 交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交； 变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。 编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。 解码(decoding)：基因型到表现型的映射。 个体（individual）：指染色体带有特征的实体； 种群（population）：个体的集合，该集合内个体数称为种群 举个程序的例子func5是目标函数，一般套程序只要更改func5中的内容。限制条件加在func5最后，用一个afa惩罚系数来约束 %%%%%%%%%%%%%%遗传算法主程序%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% clear all;%清除所有变量 close all;%清图 clc;%清屏 NP &#x3D; 50;%种群规模 L&#x3D; 21+63;%物品件数 Pc &#x3D; 0.8 ;%交叉率 Pm &#x3D; 0.05;%变异率 G&#x3D; 100;%最大遗传代数 afa &#x3D; 10;%惩罚函数系数 %func5的输入值———————————————— a &#x3D;-20.8385; b &#x3D;-4.1394; T0&#x3D;800; Gy_sum&#x3D;45; r&#x3D;0.075; k&#x3D;1440; %func5的输入值———————————————— f &#x3D; randi( [0,1],NP,L)%随机获得初始种群 %%%%%%%%%%%%%%%%%%%遗传算法循环%%%%%%%%%%%%%%%%%%%%% for h &#x3D; 1:G %号%%%%%%%%%%%%%%%%%%适应度计算%%%%%%%%%%%%%%5%%%% parfor i &#x3D; 1: NP [Fit(i) gy(i,:)]&#x3D; func5( f(i,:),a,b,T0,afa,Gy_sum,r,k,i) ; end maxFit &#x3D; max (Fit);%最大值 minFit &#x3D; min (Fit) ;%最小值 rr &#x3D; find (Fit&#x3D;&#x3D;maxFit ) ; fBest &#x3D; f (rr ( 1,1), : ) ;%历代最优个体 frr&#x3D;rr(1,1); GY&#x3D;gy(rr(1,1),:); Fit &#x3D; (Fit - minFit)&#x2F; (maxFit - minFit); %归一化适应度值%%%%%%%%%%%%%%基于轮盘赌的复制操作%%%%%%%%%%%%% sum_Fit &#x3D; sum (Fit) ; fitvalue &#x3D; Fit.&#x2F;sum_Fit; fitvalue &#x3D; cumsum ( fitvalue) ; ms &#x3D; sort (rand (NP,1 ) ); fiti &#x3D; 1; newi &#x3D; 1; while newi &lt;&#x3D; NP if(ms ( newi) ) &lt;fitvalue ( fiti) nf(newi, :) &#x3D;f (fiti, : ) ; newi &#x3D; newi + 1; else fiti &#x3D; fiti +1; end end %%%%%%%%%%%%%%%基于概率的交叉操作%%%%%%%%%%%%% for i &#x3D; 1:2:NP p &#x3D; rand; if p &lt; Pc q&#x3D; randi ( [0,1],1,L); for j &#x3D; 1:L if q(j)&#x3D;&#x3D;1 temp &#x3D; nf (i + 1,j );nf(i + 1,j) &#x3D; nf (i,j);nf ( i,j)&#x3D; temp; end end end end %%%%%%%%%%%%%基于概率的变异操作%%%%%%%%%%%%%% for m &#x3D; 1:NP parfor n &#x3D; 1:L r &#x3D; rand ( 1,1) ; if r &lt; Pm nf (m, n) &#x3D; ~nf (m, n) ; end end end f &#x3D; nf; f (1,: ) &#x3D; fBest; %保留最优个体在新种群中 trace (h) &#x3D; maxFit; %历代最优适应度 end fBest %最优个体 figure; plot (trace) xlabel (&#39;迭代次数&#39;) ylabel(&#39;目标函数值&#39;) title( &#39;适应度进化曲线&#39; ) %%%%%%%%%%%%%适应度函数%%%%%%%%%%%%% function [result,gy] &#x3D; func5 (f,a,b,T0,afa,Gy_sum,r,k,i) Gy&#x3D;zeros(1,21); day_num&#x3D;sum(f(1:21)); tspan1&#x3D;[0:0.0001:0.0039]; tspan2&#x3D;[0.004:0.0001:0.9999]; tspan3&#x3D;[0:0.0001:0.9999]; sum_H&#x3D;0; for j&#x3D;1:21 %转化为10进制 H(j)&#x3D;f(j*3-2+21)*4; H(j)&#x3D;f(j*3-1+21)*2+H(j); H(j)&#x3D;f(j*3+21)+H(j)+1; end for j&#x3D;1:21 if f(j)&#x3D;&#x3D;1 sum_H&#x3D;sum_H+H(j); end end if sum(f(1:21))&lt;7 || sum(f(1:21))&gt;18 parfor j&#x3D;1:21 Gy(j)&#x3D;Gy_sum&#x2F;sum(f(1:21)); end else x&#x3D;0;%标记变量 while x&#x3D;&#x3D;0 x&#x3D;1; for j&#x3D;1:21 if f(j)&#x3D;&#x3D;1 Gy(j)&#x3D;H(j)&#x2F;sum_H*Gy_sum; if Gy(j)&lt;2.5 H(j)&#x3D;H(j)+0.5; x&#x3D;0; elseif Gy(j)&gt;6.5 H(j)&#x3D;H(j)-0.5; x&#x3D;0; end end end sum_H&#x3D;0; for j&#x3D;1:21 if f(j)&#x3D;&#x3D;1 sum_H&#x3D;sum_H+H(j); end end end end % f(1:21) % H % Gy p&#x3D;0;%判断是否运行过 for j&#x3D;1:21 c(1)&#x3D;a*Gy(j)+b*Gy(j)^2; if f(j)&#x3D;&#x3D;1 if p&#x3D;&#x3D;0 [t,T1]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k + c(1).*T ,tspan1,T0); [t,T2]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k ,tspan2,T1(40)); T&#x3D;[T1&#39; T2&#39;]; p&#x3D;1; else if p&#x3D;&#x3D;2 [t,T1]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k + c(1).*T ,tspan1,T2(10000)); [t,T2]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k ,tspan2,T1(40)); T&#x3D;[T T1&#39; T2&#39;]; p&#x3D;1; else [t,T1]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k + c(1).*T ,tspan1,T2(9960)); [t,T2]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k ,tspan2,T1(40)); T&#x3D;[T T1&#39; T2&#39;]; p&#x3D;1; end end else if p&#x3D;&#x3D;0 [t,T2]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k ,tspan3,T0); T&#x3D;T2&#39;; p&#x3D;2; else if p&#x3D;&#x3D;2 [t,T2]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k ,tspan3,T2(10000)); T&#x3D;[T T2&#39;]; p&#x3D;2; else [t,T2]&#x3D;ode45(@(t,T) r.*T.*(k-T).&#x2F;k ,tspan3,T2(9960)); T&#x3D;[T T2&#39;]; p&#x3D;2; end end end end fit&#x3D;T0-T(210000); for i&#x3D;1:21 if T(i*10000)&gt;T0 fit&#x3D;fit-afa; end end gy&#x3D;Gy; if day_num&lt;7 || day_num&gt;18 result&#x3D;fit-afa; elseif f(1)&#x3D;&#x3D;0||f(21)&#x3D;&#x3D;0 result&#x3D;fit-20; else result&#x3D;fit; end end 效果 程序下载Download","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"广度优先遍历寻找所有路径","slug":"广度优先遍历搜索路径","date":"2021-06-03T03:01:07.683Z","updated":"2021-06-03T04:29:45.910Z","comments":true,"path":"2021/06/03/广度优先遍历搜索路径/","link":"","permalink":"http://example.com/2021/06/03/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/","excerpt":"","text":"Quick Start简述利用（实验指导书186页实验8.2）的代码，用广度优先遍历的方法，找出顶点4到顶点1的路径并输出该路径。网上大部分教程都是用递归加深度优先遍历来做的，而这次题目要求用广度遍历。 程序思想程序简述图： 附加题根据广度优先遍历的思想，一层一层地遍历符合条件的节点。路径结束条件是：1.找到与开头相同节点2.找到这个路径节点走过的节点3.找到目标节点。同时用两个栈数组分别储存前一层的节点的路径和后一层的节点的路径。程序思想是：遍历前一层节点，通过前一层节点拓展后一层节点，并把前一层节点路径复制到后一层节点中，用while周而复始。结束的条件是：后一层的栈为空。 主要函数void PathAll(AdjGraph *&amp;G,int u ,int v) &#x2F;&#x2F;G为图，u为起始点，v为终点 &#123; &#x2F;&#x2F;初始化变量和栈—————————————————————————————— int i, j;&#x2F;&#x2F;作为通用计数变量 int a, b;&#x2F;&#x2F;分别为A栈下标，B栈下标 int g;&#x2F;&#x2F;分别为A栈总数 int h;&#x2F;&#x2F;为路径数 int k;&#x2F;&#x2F;作为广度层数变量 int e;&#x2F;&#x2F;作为中间变量 int patha[10][10], pathb[10][10];&#x2F;&#x2F;走过的路径 ArcNode* p;&#x2F;&#x2F;初始化图 LinkStNode* A[10],*B[10],*C[10];&#x2F;&#x2F;A作为输入栈，B为输出栈,C作为中转栈 for (i &#x3D; 0; i &lt; 10; i++) &#123; InitStack(A[i]); InitStack(B[i]); InitStack(C[i]);; &#125; &#x2F;&#x2F;赋初值：变量、path和栈A、B、C——————————————————————— a &#x3D; 0; b &#x3D; 0; k &#x3D; 1; g &#x3D; 1; h &#x3D; 0; for (i &#x3D; 0; i &lt; 10; i++) &#123; for (j &#x3D; 0; j &lt; 10; j++) &#123; patha[i][j] &#x3D; 0; pathb[i][j] &#x3D; 0; &#125; &#125; Push(A[a], u); &#x2F;&#x2F;正式处理————————————————————————————————— while (g !&#x3D; 0) &#123; b &#x3D; 0; for (a &#x3D; 0; a &lt; g; a++) &#123; Pop(A[a], e); p &#x3D; G-&gt;adjlist[e].firstarc; Push(A[a], e); while (p !&#x3D; NULL) &#123; if (p-&gt;adjvex &#x3D;&#x3D; v) &#123; &#x2F;&#x2F;当找到v时直接输出 h++; printf(&quot;\\n路径%d：&quot;,h); while (!StackEmpty(A[a])) &#123; Pop(A[a], e); Push(C[a], e); &#125; while (!StackEmpty(C[a])) &#123; Pop(C[a], e); printf(&quot;%d &quot;, e); &#125; printf(&quot;%d &quot;, p-&gt;adjvex &#x3D;&#x3D; v); &#125; else if (p-&gt;adjvex !&#x3D; u &amp;&amp; patha[a][p-&gt;adjvex] !&#x3D; 1) &#123; &#x2F;&#x2F;符合进B栈的条件 &#x2F;&#x2F;将A赋值给B———————————————————— while (!StackEmpty(A[a]))&#123; Pop(A[a],e); Push(C[a], e); &#125; while (!StackEmpty(C[a])) &#123; Pop(C[a], e); Push(B[b], e); Push(A[a], e); &#125; &#x2F;&#x2F;——————————————————————————————— Push(B[b], p-&gt;adjvex); for (i &#x3D; 0; i &lt; 10; i++) &#123; pathb[b][i] &#x3D; patha[a][i];&#x2F;&#x2F;将patha赋值给pathb &#125; pathb[b][p-&gt;adjvex] &#x3D; 1; b++;&#x2F;&#x2F;将路径数增加 &#125; p &#x3D; p-&gt;nextarc; &#125; &#125; g &#x3D; b; for (i &#x3D; 0; i &lt; b; i++) &#123; for (j &#x3D; 0; j &lt; 10; j++) &#123; patha[i][j] &#x3D; pathb[i][j]; &#125; &#125; &#x2F;&#x2F;清空A栈 for (i &#x3D; 0; i &lt; 10; i++) &#123; while (!StackEmpty(A[i])) &#123; Pop(A[i], e); &#125; &#125; &#x2F;&#x2F;赋值B-》A for (i &#x3D; 0; i &lt; 10; i++) &#123; while (!StackEmpty(B[i])) &#123; Pop(B[i], e); Push(C[i], e); &#125; while (!StackEmpty(C[i])) &#123; Pop(C[i], e); Push(A[i], e); &#125; &#125; &#x2F;&#x2F;清空B栈 for (i &#x3D; 0; i &lt; 10; i++) &#123; while (!StackEmpty (B[i])) &#123; Pop(B[i], e); &#125;&#125; k++; &#125; &#125; 下载程序Download 小结在找路径这方面，广度优先遍历比深度优先遍历复杂很多，不论是空间复杂度还是时间复杂度。找路径还是用深度遍历递归算法比较好，除非要应对课程作业。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"好看的图片","slug":"好看的图片","date":"2021-05-30T05:25:39.106Z","updated":"2021-05-30T05:31:13.055Z","comments":true,"path":"2021/05/30/好看的图片/","link":"","permalink":"http://example.com/2021/05/30/%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%9B%BE%E7%89%87/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"STM32 F407修改配置文件的晶振频率","slug":"更改晶振","date":"2021-05-29T15:34:48.594Z","updated":"2021-05-30T05:09:27.518Z","comments":true,"path":"2021/05/29/更改晶振/","link":"","permalink":"http://example.com/2021/05/29/%E6%9B%B4%E6%94%B9%E6%99%B6%E6%8C%AF/","excerpt":"","text":"Quick Start简述在一次做单片机任务的过程中，我用野火官方串口通信的例程出现了乱码，经过我一番检查发现是晶振频率的问题。野火官方的例程中使用的是25Mhz的晶振，而我的板子使用的是8Mhz的晶振。 修改过程打开keil5，按Ctrl+f打开搜索框搜索 HES_VALUE在stm32f4xx.h文件中，将下图标的25000000改成8000000 继续搜索 PLL_M在system_stm32f4xx.c，将下图标的25改成8 这样就行了 小结其实很多问题都是配置文件的晶振频率与stm32上的晶振频率对应不上造成的，比如说我之前遇到过定时器的使用频率与计算频率相差三倍问题，lcd屏幕刷新速度很慢的问题等等，但从表象问题追究根本问题需要一定的能力。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"happy everyday","slug":"yyds","date":"2021-05-26T10:22:00.000Z","updated":"2021-05-30T05:21:33.491Z","comments":true,"path":"2021/05/26/yyds/","link":"","permalink":"http://example.com/2021/05/26/yyds/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-23T16:11:05.289Z","updated":"2021-05-30T05:06:12.302Z","comments":true,"path":"2021/05/24/hello-world/","link":"","permalink":"http://example.com/2021/05/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]}