{"meta":{"title":"Jarvis' blog","subtitle":"","description":"落叶飘零，又是一个春夏秋冬","author":"Jarvis","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-05-26T10:22:00.000Z","updated":"2021-05-29T16:47:06.207Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个热爱生活的人努力学习，天天向上！"},{"title":"categories","date":"2021-05-26T10:19:48.000Z","updated":"2021-05-26T12:50:24.945Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-26T10:21:30.000Z","updated":"2021-05-26T10:21:30.131Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"conmment","date":"2021-05-26T10:22:22.000Z","updated":"2021-05-26T14:41:06.025Z","comments":true,"path":"conmment/index.html","permalink":"http://example.com/conmment/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-26T10:19:48.000Z","updated":"2021-05-26T15:12:10.872Z","comments":false,"path":"categories/技术/index.html","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"广度优先遍历寻找所有路径","slug":"广度优先遍历搜索路径","date":"2021-06-03T03:01:07.683Z","updated":"2021-06-03T04:29:45.910Z","comments":true,"path":"2021/06/03/广度优先遍历搜索路径/","link":"","permalink":"http://example.com/2021/06/03/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84/","excerpt":"","text":"Quick Start简述利用（实验指导书186页实验8.2）的代码，用广度优先遍历的方法，找出顶点4到顶点1的路径并输出该路径。网上大部分教程都是用递归加深度优先遍历来做的，而这次题目要求用广度遍历。 程序思想程序简述图： 附加题根据广度优先遍历的思想，一层一层地遍历符合条件的节点。路径结束条件是：1.找到与开头相同节点2.找到这个路径节点走过的节点3.找到目标节点。同时用两个栈数组分别储存前一层的节点的路径和后一层的节点的路径。程序思想是：遍历前一层节点，通过前一层节点拓展后一层节点，并把前一层节点路径复制到后一层节点中，用while周而复始。结束的条件是：后一层的栈为空。 主要函数void PathAll(AdjGraph *&amp;G,int u ,int v) &#x2F;&#x2F;G为图，u为起始点，v为终点 &#123; &#x2F;&#x2F;初始化变量和栈—————————————————————————————— int i, j;&#x2F;&#x2F;作为通用计数变量 int a, b;&#x2F;&#x2F;分别为A栈下标，B栈下标 int g;&#x2F;&#x2F;分别为A栈总数 int h;&#x2F;&#x2F;为路径数 int k;&#x2F;&#x2F;作为广度层数变量 int e;&#x2F;&#x2F;作为中间变量 int patha[10][10], pathb[10][10];&#x2F;&#x2F;走过的路径 ArcNode* p;&#x2F;&#x2F;初始化图 LinkStNode* A[10],*B[10],*C[10];&#x2F;&#x2F;A作为输入栈，B为输出栈,C作为中转栈 for (i &#x3D; 0; i &lt; 10; i++) &#123; InitStack(A[i]); InitStack(B[i]); InitStack(C[i]);; &#125; &#x2F;&#x2F;赋初值：变量、path和栈A、B、C——————————————————————— a &#x3D; 0; b &#x3D; 0; k &#x3D; 1; g &#x3D; 1; h &#x3D; 0; for (i &#x3D; 0; i &lt; 10; i++) &#123; for (j &#x3D; 0; j &lt; 10; j++) &#123; patha[i][j] &#x3D; 0; pathb[i][j] &#x3D; 0; &#125; &#125; Push(A[a], u); &#x2F;&#x2F;正式处理————————————————————————————————— while (g !&#x3D; 0) &#123; b &#x3D; 0; for (a &#x3D; 0; a &lt; g; a++) &#123; Pop(A[a], e); p &#x3D; G-&gt;adjlist[e].firstarc; Push(A[a], e); while (p !&#x3D; NULL) &#123; if (p-&gt;adjvex &#x3D;&#x3D; v) &#123; &#x2F;&#x2F;当找到v时直接输出 h++; printf(&quot;\\n路径%d：&quot;,h); while (!StackEmpty(A[a])) &#123; Pop(A[a], e); Push(C[a], e); &#125; while (!StackEmpty(C[a])) &#123; Pop(C[a], e); printf(&quot;%d &quot;, e); &#125; printf(&quot;%d &quot;, p-&gt;adjvex &#x3D;&#x3D; v); &#125; else if (p-&gt;adjvex !&#x3D; u &amp;&amp; patha[a][p-&gt;adjvex] !&#x3D; 1) &#123; &#x2F;&#x2F;符合进B栈的条件 &#x2F;&#x2F;将A赋值给B———————————————————— while (!StackEmpty(A[a]))&#123; Pop(A[a],e); Push(C[a], e); &#125; while (!StackEmpty(C[a])) &#123; Pop(C[a], e); Push(B[b], e); Push(A[a], e); &#125; &#x2F;&#x2F;——————————————————————————————— Push(B[b], p-&gt;adjvex); for (i &#x3D; 0; i &lt; 10; i++) &#123; pathb[b][i] &#x3D; patha[a][i];&#x2F;&#x2F;将patha赋值给pathb &#125; pathb[b][p-&gt;adjvex] &#x3D; 1; b++;&#x2F;&#x2F;将路径数增加 &#125; p &#x3D; p-&gt;nextarc; &#125; &#125; g &#x3D; b; for (i &#x3D; 0; i &lt; b; i++) &#123; for (j &#x3D; 0; j &lt; 10; j++) &#123; patha[i][j] &#x3D; pathb[i][j]; &#125; &#125; &#x2F;&#x2F;清空A栈 for (i &#x3D; 0; i &lt; 10; i++) &#123; while (!StackEmpty(A[i])) &#123; Pop(A[i], e); &#125; &#125; &#x2F;&#x2F;赋值B-》A for (i &#x3D; 0; i &lt; 10; i++) &#123; while (!StackEmpty(B[i])) &#123; Pop(B[i], e); Push(C[i], e); &#125; while (!StackEmpty(C[i])) &#123; Pop(C[i], e); Push(A[i], e); &#125; &#125; &#x2F;&#x2F;清空B栈 for (i &#x3D; 0; i &lt; 10; i++) &#123; while (!StackEmpty (B[i])) &#123; Pop(B[i], e); &#125;&#125; k++; &#125; &#125; 下载程序Download 小结在找路径这方面，广度优先遍历比深度优先遍历复杂很多，不论是空间复杂度还是时间复杂度。找路径还是用深度遍历递归算法比较好，除非要应对课程作业。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"好看的图片","slug":"好看的图片","date":"2021-05-30T05:25:39.106Z","updated":"2021-05-30T05:31:13.055Z","comments":true,"path":"2021/05/30/好看的图片/","link":"","permalink":"http://example.com/2021/05/30/%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%9B%BE%E7%89%87/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"STM32 F407修改配置文件的晶振频率","slug":"更改晶振","date":"2021-05-29T15:34:48.594Z","updated":"2021-05-30T05:09:27.518Z","comments":true,"path":"2021/05/29/更改晶振/","link":"","permalink":"http://example.com/2021/05/29/%E6%9B%B4%E6%94%B9%E6%99%B6%E6%8C%AF/","excerpt":"","text":"Quick Start简述在一次做单片机任务的过程中，我用野火官方串口通信的例程出现了乱码，经过我一番检查发现是晶振频率的问题。野火官方的例程中使用的是25Mhz的晶振，而我的板子使用的是8Mhz的晶振。 修改过程打开keil5，按Ctrl+f打开搜索框搜索 HES_VALUE在stm32f4xx.h文件中，将下图标的25000000改成8000000 继续搜索 PLL_M在system_stm32f4xx.c，将下图标的25改成8 这样就行了 小结其实很多问题都是配置文件的晶振频率与stm32上的晶振频率对应不上造成的，比如说我之前遇到过定时器的使用频率与计算频率相差三倍问题，lcd屏幕刷新速度很慢的问题等等，但从表象问题追究根本问题需要一定的能力。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"happy everyday","slug":"yyds","date":"2021-05-26T10:22:00.000Z","updated":"2021-05-30T05:21:33.491Z","comments":true,"path":"2021/05/26/yyds/","link":"","permalink":"http://example.com/2021/05/26/yyds/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-23T16:11:05.289Z","updated":"2021-05-30T05:06:12.302Z","comments":true,"path":"2021/05/24/hello-world/","link":"","permalink":"http://example.com/2021/05/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]}